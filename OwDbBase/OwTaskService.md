# OwTaskService 设计概要（最终版）

## 1. 设计目标

- 提供通用、可扩展的长时间运行任务基础服务类，适用于业务系统扩展。
- 支持任务的创建、启动、状态查询。
- 控制并发任务数，单机并发不超过CPU核心数，超出自动排队。

## 2. 架构与机制

- **服务入口**：`OwTaskService`，通过 .NET 6 标准依赖注入注册。
- **线程隔离**：每个任务独立线程，业务异常不影响主流程。
- **并发控制**：采用同步原语（如信号量）动态限制并发数，强制≤CPU核心数。
- **数据库持久化**：任务数据、状态、结果、异常信息全部持久化，便于后续查询。
- **日志体系**：
  - 调度、排队、开始、结束、一般异常等流程记录为 debug 级别日志。
  - 任务错误或异常结尾记录为 warning 级别日志。
- **服务类与方法调用**：通过依赖注入查找并调用业务方法，业务代码在独立线程执行。

## 3. 任务数据模型

- **唯一标识**：任务ID（Guid）。
- **服务类名称、方法名**：表征任务实际执行逻辑，数据库联合索引便于检索。
- **参数与结果**：`Dictionary<string, string>`，内容长度无限制，键值定义由业务自定，本服务类不作限制。
- **状态**：按位枚举（byte/ushort），如待处理、执行中、已完成、失败等。
- **错误信息**：异常内容全部序列化为字符串存储，无需结构化，便于排查。
- **创建者**：任务创建者身份仅用一个 GUID 字段记录，由调用者指定。
- **租户支持**：预留一个租户 GUID 字段区分多租户，目前仅单一租户。

## 4. 操作流程

1. **任务创建**：指定服务类、方法名、参数，生成ID，写入数据库，记录创建者GUID和租户GUID（如有）。
2. **调度与执行**：依赖注入获取服务类及方法，参数反序列化后在独立线程执行。并发数超出自动排队，由同步原语动态控制。
3. **状态与错误更新**：执行完毕后，更新状态与结果。若异常，完整异常信息（字符串）写入数据库，相关日志分级记录。
4. **查询**：实时查询任务状态和结果，无需身份验证，但记录发起人和租户信息。

## 5. 约束与说明

- 不支持任务取消、暂停、恢复。
- 不考虑任务唯一性、进度上报、自动重试、分布式部署。
- 任务数量无限制，任务列表无限增长，无需归档、分表、清理。
- 不处理系统重启后的任务恢复。
- 参数和结果内容长度无限制。
- 仅作为服务类由业务代码调用，不涉及 API、gRPC 或消息接口。
- 敏感数据、脱敏、加密等由业务层自理。

## 6. 技术选型

- **开发语言**：C# (.NET 6)
- **ORM**：Entity Framework Core
- **数据库**：关系型数据库（如 SQL Server、SQLite 等）
- **并发控制**：.NET Task/线程 + 同步原语
- **日志**：.NET 内置日志（8级别，debug/warning等）
- **服务注册**：.NET 6 标准依赖注入

## 7. 可扩展建议

- 可按业务需求扩展任务优先级、分组、标签、运维监控等功能。
- 多租户支持已预留字段，未来可扩展为多租户场景。

---